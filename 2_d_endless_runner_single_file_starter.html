<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2D Endless Runner</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0f172a; color: #e2e8f0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .wrap { display:flex; flex-direction:column; align-items:center; gap:10px; height:100%; padding:16px; box-sizing:border-box; }
    h1 { margin: 0; font-size: clamp(18px, 3vw, 28px); letter-spacing: .5px; }
    .hud { display:flex; align-items:center; justify-content:space-between; width:min(900px, 96%); gap:12px; }
    .btn { background:#1f2937; border:1px solid #334155; color:#e5e7eb; padding:8px 12px; border-radius:12px; cursor:pointer; font-weight:600; }
    .btn:hover { filter:brightness(1.1); }
    #game { width:min(900px, 96%); aspect-ratio: 16 / 9; border-radius:16px; border:2px solid #334155; background: linear-gradient(#0b1024 0%, #0b1024 70%, #0a0f20 100%); display:block; }
    .help { opacity:.85; font-size:14px; }
    .kbd { background:#111827; border:1px solid #374151; padding:2px 6px; border-radius:6px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>2D Endless Runner</h1>
    <div class="hud">
      <div id="score">Score: 0</div>
      <div>
        <button id="play" class="btn">▶️ Play / Restart</button>
        <button id="pause" class="btn">⏸️ Pause</button>
      </div>
    </div>
    <canvas id="game"></canvas>
    <div class="help">
      Controls: <span class="kbd">Space</span> or <span class="kbd">↑</span> to Jump • <span class="kbd">P</span> to Pause • Tap on mobile
    </div>
  </div>

  <script>
  // --- High-DPI Canvas Setup -------------------------------------------------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  function resize() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * DPR);
    canvas.height = Math.floor(rect.height * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // draw in CSS pixels
  }
  addEventListener('resize', resize, { passive: true });
  resize();

  // --- Game State ------------------------------------------------------------
  const state = {
    running: false,
    paused: false,
    score: 0,
    highScore: Number(localStorage.getItem('runner.highscore') || 0),
    t: 0,
    speed: 6, // base world speed (px/frame at 60fps)
    gravity: 0.8,
    jumpV: -14,
    groundY: () => canvas.height / DPR - 64,
  };
  const scoreEl = document.getElementById('score');
  const playBtn = document.getElementById('play');
  const pauseBtn = document.getElementById('pause');

  // --- Entities --------------------------------------------------------------
  class Player {
    constructor() { this.reset(); }
    reset() {
      this.w = 40; this.h = 48;
      this.x = 60; this.y = state.groundY() - this.h;
      this.vy = 0; this.onGround = true; this.dead = false;
      this.anim = 0;
    }
    jump() {
      if (this.onGround && !this.dead) {
        this.vy = state.jumpV; this.onGround = false;
      }
    }
    update() {
      this.vy += state.gravity;
      this.y += this.vy;
      const gy = state.groundY() - this.h;
      if (this.y >= gy) { this.y = gy; this.vy = 0; this.onGround = true; }
      this.anim += 0.2;
    }
    draw() {
      // body
      ctx.fillStyle = '#38bdf8';
      ctx.fillRect(this.x, this.y, this.w, this.h);
      // eyes
      ctx.fillStyle = '#0b1024';
      ctx.fillRect(this.x + 8, this.y + 12, 6, 6);
      ctx.fillRect(this.x + 26, this.y + 12, 6, 6);
      // legs (simple running animation)
      const k = Math.sin(this.anim) * 6;
      ctx.fillStyle = '#e2e8f0';
      ctx.fillRect(this.x + 6, this.y + this.h - 10, 10, 10);
      ctx.fillRect(this.x + 24, this.y + this.h - 10 + k, 10, 10);
    }
    get rect(){ return {x:this.x, y:this.y, w:this.w, h:this.h}; }
  }

  class Obstacle {
    constructor(x){
      this.w = 28 + Math.random()*20;
      this.h = 20 + Math.random()*40;
      this.x = x; this.y = state.groundY() - this.h;
      this.passed = false;
      this.color = ['#f472b6','#f59e0b','#34d399','#a78bfa'][Math.floor(Math.random()*4)];
    }
    update(){ this.x -= state.speed; }
    offscreen(){ return this.x + this.w < 0; }
    draw(){ ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.w, this.h); }
    get rect(){ return {x:this.x, y:this.y, w:this.w, h:this.h}; }
  }

  // --- Helpers ---------------------------------------------------------------
  function rectsOverlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

  // Parallax stars background
  const stars = Array.from({length:120}, () => ({
    x: Math.random() * canvas.width / DPR,
    y: Math.random() * canvas.height / DPR,
    s: Math.random() * 2 + 1,
    z: Math.random() * 0.6 + 0.2
  }));

  function drawBackground(){
    // sky gradient already via CSS; add parallax stars
    ctx.save();
    for(const st of stars){
      const sx = (st.x - (state.t * (st.z*0.5))) % (canvas.width / DPR);
      ctx.globalAlpha = st.z + 0.2;
      ctx.fillStyle = '#94a3b8';
      ctx.fillRect((sx<0? sx + canvas.width/DPR : sx), st.y, st.s, st.s);
    }
    ctx.restore();

    // ground
    ctx.fillStyle = '#111827';
    ctx.fillRect(0, state.groundY(), canvas.width / DPR, canvas.height / DPR);
    // ground stripes
    const stripeW = 40;
    const offset = (state.t * state.speed) % stripeW;
    ctx.fillStyle = '#1f2937';
    for(let x = -stripeW; x < canvas.width / DPR + stripeW; x += stripeW){
      ctx.fillRect(x - offset, state.groundY()+32, 20, 4);
    }
  }

  // --- Game Loop -------------------------------------------------------------
  const player = new Player();
  let obstacles = [];
  let nextSpawn = 0;

  function reset(){
    state.score = 0; state.t = 0; state.speed = 6;
    obstacles = []; nextSpawn = 0; player.reset();
    state.running = true; state.paused = false;
    updateHUD();
    loop(0);
  }

  function updateHUD(){
    scoreEl.textContent = `Score: ${Math.floor(state.score)}  •  Best: ${state.highScore}`;
  }

  let lastTs = 0;
  function loop(ts){
    if(!state.running) return;
    if(state.paused){ requestAnimationFrame(loop); return; }
    const dt = (ts - lastTs) || 16.67; lastTs = ts;
    state.t += dt/16.67; // approx frames

    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackground();

    // spawn obstacles
    if(state.t > nextSpawn){
      const gap = 70 + Math.random()*60; // time in frames
      nextSpawn = state.t + gap/ (state.speed/6);
      const lastX = obstacles.length ? obstacles[obstacles.length-1].x : canvas.width/DPR + 200;
      const spawnX = Math.max(canvas.width/DPR + 40, lastX + 120 + Math.random()*140);
      obstacles.push(new Obstacle(spawnX));
    }

    // update / draw obstacles
    for(const ob of obstacles){
      ob.update(); ob.draw();
      if(!ob.passed && ob.x + ob.w < player.x){
        ob.passed = true; state.score += 1; // score per obstacle passed
        state.speed = Math.min(16, state.speed + 0.05); // gradually speed up
      }
      if(rectsOverlap(player.rect, ob.rect)){
        // game over
        state.running = false; player.dead = true;
        state.highScore = Math.max(state.highScore, Math.floor(state.score));
        localStorage.setItem('runner.highscore', state.highScore);
        updateHUD();
        drawGameOver();
        return;
      }
    }
    obstacles = obstacles.filter(o => !o.offscreen());

    // player update
    player.update();
    player.draw();

    // score
    updateHUD();

    requestAnimationFrame(loop);
  }

  function drawGameOver(){
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#0b1024';
    ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR);
    ctx.restore();

    ctx.fillStyle = '#e2e8f0';
    ctx.textAlign = 'center';
    ctx.font = 'bold 32px system-ui';
    ctx.fillText('Game Over', canvas.width/(2*DPR), canvas.height/(2*DPR) - 20);
    ctx.font = '16px system-ui';
    ctx.fillText('Press Play / Restart or Space', canvas.width/(2*DPR), canvas.height/(2*DPR) + 12);
  }

  // --- Input -----------------------------------------------------------------
  function handleJump(){ if(!state.running){ reset(); } else { player.jump(); } }

  addEventListener('keydown', (e) => {
    if(e.code === 'Space' || e.code === 'ArrowUp'){ e.preventDefault(); handleJump(); }
    if(e.key === 'p' || e.key === 'P'){ togglePause(); }
  });

  canvas.addEventListener('pointerdown', handleJump);

  function togglePause(){
    if(!state.running) return;
    state.paused = !state.paused;
    if(!state.paused) requestAnimationFrame(loop);
  }

  // --- Buttons ---------------------------------------------------------------
  playBtn.addEventListener('click', () => {
    if(!state.running) reset(); else { // if running, treat like restart
      state.running = false;
      setTimeout(reset, 0);
    }
  });
  pauseBtn.addEventListener('click', togglePause);

  // Auto-start
  reset();
  </script>
</body>
</html>
